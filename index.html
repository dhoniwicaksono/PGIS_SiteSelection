<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGIS Prototype — Collect Points & Export CSV</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #map {
        height: 100%;
      }
      body {
        font-family: Arial, Helvetica, sans-serif;
      }

      /* Left sidebar */
      #sidebar {
        position: absolute;
        top: 8px;
        left: 8px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.98);
        padding: 10px;
        border-radius: 6px;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.25);
        width: 320px;
        max-height: 90vh;
        overflow: auto;
      }

      /* Right sidebar */
      #sidebarRight {
        position: absolute;
        top: 8px;
        right: 8px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.98);
        padding: 10px;
        border-radius: 6px;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.25);
        width: 320px;
        max-height: 90vh;
        overflow: auto;
      }

      @media (max-width: 700px) {
        #sidebar,
        #sidebarRight {
          position: fixed;
          left: 0;
          right: 0;
          bottom: 0;
          top: auto;
          width: 100%;
          max-height: 45vh;
          border-radius: 12px 12px 0 0;
          padding: 10px 12px;
        }
      }

      .btn {
        display: inline-block;
        padding: 8px 12px;
        margin: 6px 4px;
        border-radius: 6px;
        border: 1px solid #2c7be5;
        background: #2c7be5;
        color: #fff;
        cursor: pointer;
        font-size: 14px;
      }
      .btn.secondary {
        background: #fff;
        color: #2c7be5;
      }
      .btn.tertiary {
        background: #f5f5f5;
        color: #333;
        border: 1px solid #ddd;
      }
      .smallBtn {
        padding: 4px 6px;
        font-size: 12px;
      }

      label {
        display: block;
        margin-top: 8px;
        font-weight: 600;
      }
      /* Custom style for radio/checkbox labels in sidebar */
      .ctrl-label {
        display: flex;
        align-items: center;
        margin-top: 6px; 
        font-weight: normal; 
        cursor: pointer;
        font-size: 14px;
      }
      .ctrl-label input {
        width: auto;
        margin-top: 0;
        margin-right: 8px;
        cursor: pointer;
      }

      /* Legend dot style */
      .legend-dot {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 6px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
        margin-top: 4px;
        color: #555;
      }

      input[type="text"],
      select,
      textarea {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
        margin-top: 6px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      textarea {
        resize: vertical;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
      }
      table th,
      table td {
        border: 1px solid #ddd;
        padding: 6px;
        font-size: 13px;
      }
      .small {
        font-size: 13px;
        color: #555;
      }

      @media (max-width: 700px) {
        table th:nth-child(5),
        table td:nth-child(5),
        table th:nth-child(6),
        table td:nth-child(6) {
          display: none;
        }
        .btn {
          font-size: 13px;
          padding: 8px 10px;
        }
      }

      .leaflet-control-layers {
        z-index: 1200;
      }

      /* admin label style and buffer variants */
      .admin-label {
        background: rgba(255, 255, 255, 0.85);
        padding: 2px 4px;
        border-radius: 4px;
        font-size: 11px;
        color: #111;
      }
      .admin-label-prov {
        text-shadow: 0 0 8px #fff, 0 0 8px #fff;
        font-weight: 700;
      }
      .admin-label-kab {
        text-shadow: 0 0 6px #fff, 0 0 6px #fff;
      }
      .admin-label-kec {
        text-shadow: 0 0 4px #fff, 0 0 4px #fff;
      }
      .admin-label-desa {
        text-shadow: 0 0 2px #fff, 0 0 2px #fff;
      }

      /* suggestion box */
      #admin_suggestions div:hover {
        background: #f5f8ff;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <div id="sidebar">
      <h3 style="margin: 6px 0">Collector — Preference Mapping (MaxEnt)</h3>
      <div class="small">Klik peta untuk menambahkan titik. Isi atribut di form, lalu tekan <b>Save Point</b>. Minimal <b>10 titik</b> per responden direkomendasikan.</div>

      <label>Respondent ID</label>
      <input type="text" id="respondent_id" placeholder="e.g. R01" />

      <label>Stakeholder Group</label>
      <select id="stakeholder_group">
        <option value="Pemerintah_Desa">Pemerintah Desa</option>
        <option value="Pelaku_Usaha">Pelaku Usaha</option>
        <option value="Dinas_Terkait">Dinas Terkait</option>
        <option value="Lainnya">Lainnya</option>
      </select>

      <label>Mapping Object</label>
      <input type="text" id="mapping_object" placeholder="contoh: Pendidikan" />

      <label>Point ID (optional)</label>
      <input type="text" id="point_id" placeholder="auto: R01_P1" />

      <label>Reason (optional)</label>
      <textarea id="reason" rows="2" placeholder="Contoh: dekat jalan kolektor dan pasar"></textarea>

      <label>Map Source</label>
      <select id="map_source">
        <option value="webGIS">webGIS</option>
        <option value="peta_cetak">peta_cetak</option>
        <option value="gps">gps</option>
      </select>

      <label>Accuracy (m) — optional</label>
      <input type="text" id="accuracy_m" placeholder="e.g. 10" />

      <div style="margin-top: 10px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; align-items: center">
        <button id="savePointBtn" class="btn">Save Point</button>
        <button id="clearFormBtn" class="btn secondary">Clear Form</button>
        <button id="centerBtn" class="btn tertiary">Center Map</button>
      </div>

      <hr />

      <div class="small"><b>Points collected for current respondent:</b></div>
      <div id="pointsCount">0 points</div>

      <table id="pointsTable" style="display: none">
        <thead>
          <tr>
            <th>#</th>
            <th>ID</th>
            <th>Mapping Object</th>
            <th>Lat</th>
            <th>Lon</th>
            <th>Reason</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

      <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap">
        <button id="exportCsv" class="btn">Export CSV</button>
        <button id="exportGeojson" class="btn">Export GeoJSON</button>
        <button id="clearAll" class="btn secondary">Clear All Points</button>
      </div>

      <hr />
      <div class="small">Instruksi singkat: 1) Isi Respondent ID. 2) Klik lokasi pada peta. 3) Edit atribut jika perlu. 4) Tekan "Save Point". 5) Setelah selesai, tekan Export CSV.</div>
    </div>

    <div id="sidebarRight">
      <!-- Basemap Section -->
      <h3 style="margin: 6px 0">Basemap</h3>
      <div class="small" style="margin-bottom: 8px;">Pilih tampilan peta dasar.</div>
      <div style="margin-bottom: 12px;">
        <label class="ctrl-label">
          <input type="radio" name="basemap_select" value="osm" checked /> OSM Standard
        </label>
        <label class="ctrl-label">
          <input type="radio" name="basemap_select" value="esri" /> Esri Satellite
        </label>
        <label class="ctrl-label">
          <input type="radio" name="basemap_select" value="opnv" /> OPNVKarte (Transport)
        </label>
      </div>
      
      <hr />

      <!-- NEW: Layers Section -->
      <h3 style="margin: 6px 0">Layers</h3>
      <div style="margin-bottom: 12px;">
        <label class="ctrl-label">
          <input type="checkbox" id="layer_kantor_pemerintah" /> Kantor Pemerintahan
        </label>
        <!-- Legend for Gov Office -->
        <div id="legend_kantor" style="margin-left: 24px; margin-top: 4px; display:none;">
          <div class="legend-item"><span class="legend-dot" style="background:#d32f2f"></span>Gubernur / DIY</div>
          <div class="legend-item"><span class="legend-dot" style="background:#f57c00"></span>Bupati / Walikota</div>
          <div class="legend-item"><span class="legend-dot" style="background:#1976d2"></span>Kecamatan / Kemantren</div>
          <div class="legend-item"><span class="legend-dot" style="background:#388e3c"></span>Kelurahan / Desa</div>
          <div class="legend-item"><span class="legend-dot" style="background:#757575"></span>Lainnya</div>
        </div>
      </div>

      <hr />

      <h3 style="margin: 6px 0">Tools</h3>
      <div class="small">Tool cepat untuk pengguna.</div>

      <div style="margin-top: 10px; display: flex; flex-direction: column; gap: 12px; align-items: center">
        <button id="getLocationBtn" class="btn" style="width: 80%; text-align: center">Get my location</button>
        <div style="display: flex; gap: 8px; justify-content: center; width: 100%">
          <button id="zoomInBtn" class="btn tertiary" style="width: 40%; text-align: center">Zoom In</button>
          <button id="zoomOutBtn" class="btn tertiary" style="width: 40%; text-align: center">Zoom Out</button>
        </div>
      </div>
      
      <!-- Administrative Search -->
      <div id="admin_search_container" style="margin-top: 12px; border-top: 1px solid #ddd; padding-top: 12px;">
      </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
      // --- Map init ---
      var osm = L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19, attribution: "© OpenStreetMap contributors" });

      var Esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
	    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
      });

      var OPNVKarte = L.tileLayer('https://tileserver.memomaps.de/tilegen/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: 'Map <a href="https://memomaps.de/">memomaps.de</a> <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      });

      // Default map with OSM
      var map = L.map("map", { center: [-7.8, 110.37], zoom: 12, layers: [osm] });
      L.control.scale().addTo(map);

      // --- CUSTOM BASEMAP CONTROL LOGIC ---
      var basemapRadios = document.querySelectorAll('input[name="basemap_select"]');
      basemapRadios.forEach(function(radio) {
        radio.addEventListener('change', function(e) {
          var val = e.target.value;
          if (map.hasLayer(osm)) map.removeLayer(osm);
          if (map.hasLayer(Esri_WorldImagery)) map.removeLayer(Esri_WorldImagery);
          if (map.hasLayer(OPNVKarte)) map.removeLayer(OPNVKarte);

          if (val === 'osm') {
             map.addLayer(osm);
          } else if (val === 'esri') {
             map.addLayer(Esri_WorldImagery);
          } else if (val === 'opnv') {
             map.addLayer(OPNVKarte);
          }
        });
      });

      // --- LAYER KANTOR PEMERINTAHAN (Unique Symbol) ---
      var govLayer = null;
      var govLayerUrl = "TOPONIMI_KANTORPEMERINTAH_PT.geojson"; // Assuming root level upload

      function getGovColor(kategori) {
        if (!kategori) return "#757575";
        var k = kategori.toLowerCase();
        if (k.includes("gubernur") || k.includes("daerah istimewa")) return "#d32f2f"; // Merah
        if (k.includes("bupati") || k.includes("walikota") || k.includes("kota")) return "#f57c00"; // Oranye
        if (k.includes("camat") || k.includes("kemantren")) return "#1976d2"; // Biru
        if (k.includes("kelurahan") || k.includes("desa") || k.includes("kalurahan")) return "#388e3c"; // Hijau
        return "#757575"; // Abu-abu default
      }

      function loadGovLayer() {
        if (govLayer) {
           map.addLayer(govLayer);
           return;
        }
        
        // Try paths: root, then data/
        var paths = [govLayerUrl, "data/" + govLayerUrl];
        
        var loadPromise = new Promise(function(resolve, reject) {
            // Recursive fetch helper
            function tryFetch(idx) {
                if (idx >= paths.length) {
                    reject("File not found");
                    return;
                }
                fetch(paths[idx])
                .then(function(r) { 
                    if (!r.ok) throw new Error("404");
                    return r.json(); 
                })
                .then(function(data) { resolve(data); })
                .catch(function() { tryFetch(idx + 1); });
            }
            tryFetch(0);
        });

        loadPromise.then(function(data) {
           govLayer = L.geoJSON(data, {
             pointToLayer: function(feature, latlng) {
                var cat = feature.properties.kategori || "";
                var color = getGovColor(cat);
                return L.circleMarker(latlng, {
                    radius: 6,
                    fillColor: color,
                    color: "#fff",
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.9
                });
             },
             onEachFeature: function(feature, layer) {
                var p = feature.properties;
                var content = "<b>" + (p.namobj || "Kantor Pemerintah") + "</b><br/>";
                content += "Kategori: " + (p.kategori || "-") + "<br/>";
                if(p.metadata) content += "<i>" + p.metadata + "</i>";
                layer.bindPopup(content);
             }
           }).addTo(map);
        }).catch(function(err) {
            console.error("Failed to load Gov Layer", err);
            alert("Gagal memuat layer Kantor Pemerintahan. Pastikan file " + govLayerUrl + " telah diunggah.");
            document.getElementById("layer_kantor_pemerintah").checked = false;
        });
      }

      document.getElementById("layer_kantor_pemerintah").addEventListener("change", function(e) {
         var legend = document.getElementById("legend_kantor");
         if (e.target.checked) {
            loadGovLayer();
            if(legend) legend.style.display = "block";
         } else {
            if (govLayer && map.hasLayer(govLayer)) {
                map.removeLayer(govLayer);
            }
            if(legend) legend.style.display = "none";
         }
      });


      // --- State ---
      var allPoints = [];
      var tempMarker = null;

      // --- DOM ---
      var respondentIdEl = document.getElementById("respondent_id");
      var stakeholderEl = document.getElementById("stakeholder_group");
      var mappingObjectEl = document.getElementById("mapping_object");
      var pointIdEl = document.getElementById("point_id");
      var reasonEl = document.getElementById("reason");
      var mapSourceEl = document.getElementById("map_source");
      var accuracyEl = document.getElementById("accuracy_m");
      var saveBtn = document.getElementById("savePointBtn");
      var clearFormBtn = document.getElementById("clearFormBtn");
      var pointsCountEl = document.getElementById("pointsCount");
      var pointsTable = document.getElementById("pointsTable");
      var pointsTableBody = pointsTable.querySelector("tbody");
      var exportCsvBtn = document.getElementById("exportCsv");
      var exportGeoBtn = document.getElementById("exportGeojson");
      var clearAllBtn = document.getElementById("clearAll");
      var centerBtn = document.getElementById("centerBtn");
      var getLocationBtn = document.getElementById("getLocationBtn");
      var zoomInBtn = document.getElementById("zoomInBtn");
      var zoomOutBtn = document.getElementById("zoomOutBtn");

      function currentRespondentId() {
        return respondentIdEl.value ? respondentIdEl.value.trim() : "";
      }
      function pointsForRespondent(rid) {
        return allPoints.filter(function (p) {
          return p.respondent_id === rid;
        });
      }

      function updatePointsUI() {
        var rid = currentRespondentId();
        var pts = rid ? pointsForRespondent(rid) : [];
        pointsCountEl.textContent = pts.length + " points";
        if (!pts || pts.length === 0) {
          pointsTable.style.display = "none";
          pointsTableBody.innerHTML = "";
          return;
        }
        pointsTable.style.display = "table";
        pointsTableBody.innerHTML = "";
        pts.forEach(function (p, i) {
          var tr = document.createElement("tr");
          tr.innerHTML =
            "<td>" +
            (i + 1) +
            "</td>" +
            "<td>" +
            p.point_id +
            "</td>" +
            "<td>" +
            (p.mapping_object ? p.mapping_object : "") +
            "</td>" +
            "<td>" +
            p.latitude.toFixed(6) +
            "</td>" +
            "<td>" +
            p.longitude.toFixed(6) +
            "</td>" +
            "<td>" +
            (p.reason ? p.reason.substring(0, 20) : "") +
            "</td>" +
            '<td><button data-pid="' +
            p.point_id +
            '" class="btn secondary smallBtn">Del</button></td>';
          pointsTableBody.appendChild(tr);
        });
        // attach delete handlers
        pointsTableBody.querySelectorAll(".smallBtn").forEach(function (btn) {
          btn.addEventListener("click", function () {
            var pid = this.getAttribute("data-pid");
            var rid = currentRespondentId();
            var idx = allPoints.findIndex(function (x) {
              return x.point_id === pid && x.respondent_id === rid;
            });
            if (idx >= 0) {
              if (allPoints[idx].marker) map.removeLayer(allPoints[idx].marker);
              allPoints.splice(idx, 1);
              updatePointsUI();
            }
          });
        });
      }

      function resetFormFields() {
        if (pointIdEl) {
          pointIdEl.value = "";
          pointIdEl.removeAttribute("data-lat");
          pointIdEl.removeAttribute("data-lon");
        }
        if (reasonEl) reasonEl.value = "";
        if (mapSourceEl) mapSourceEl.value = "webGIS";
        if (accuracyEl) accuracyEl.value = "";
      }

      // helper: compute next index for a base mapping object for a respondent
      function getNextMappingIndex(base, rid) {
        if (!base) return 1;
        var prefix = base + "_";
        var maxIndex = 0;
        allPoints.forEach(function (p) {
          if (rid && p.respondent_id !== rid) return;
          if (!p.mapping_object) return;
          if (p.mapping_object === base) {
            maxIndex = Math.max(maxIndex, 1);
            return;
          }
          if (p.mapping_object.indexOf(prefix) === 0) {
            var tail = p.mapping_object.slice(prefix.length);
            var n = parseInt(tail, 10);
            if (!isNaN(n)) maxIndex = Math.max(maxIndex, n);
          }
        });
        return maxIndex + 1;
      }

      // Map click handler
      map.on("click", function (e) {
        if (tempMarker) map.removeLayer(tempMarker);
        tempMarker = L.marker(e.latlng, { draggable: true }).addTo(map);
        tempMarker.on("dragend", function (ev) {
          var ll = ev.target.getLatLng();
          if (pointIdEl) {
            pointIdEl.dataset.lat = ll.lat;
            pointIdEl.dataset.lon = ll.lng;
          }
        });

        var rid = currentRespondentId() || "R?_";
        var idx = 1;
        if (currentRespondentId()) idx = pointsForRespondent(currentRespondentId()).length + 1;

        if (pointIdEl) pointIdEl.value = rid + "_P" + idx;

        // auto-fill mapping object
        try {
          if (mappingObjectEl) {
            var val = mappingObjectEl.value ? mappingObjectEl.value.trim() : "";
            if (!val) {
              var mo = rid && rid !== "R?_" ? rid + "_MO" + idx : "MO_P" + (allPoints.length + 1);
              mappingObjectEl.value = mo;
            } else {
              var m = val.match(/^(.*?)[_\-]?0*(\d+)$/);
              var base = m && m[1] ? m[1] : val;
              var next = getNextMappingIndex(base, currentRespondentId());
              var formatted = next < 10 ? "0" + next : "" + next;
              mappingObjectEl.value = base + "_" + formatted;
            }
          }
        } catch (err) {}

        if (pointIdEl) {
          pointIdEl.dataset.lat = e.latlng.lat;
          pointIdEl.dataset.lon = e.latlng.lng;
        }
      });

      // Save point
      if (saveBtn)
        saveBtn.addEventListener("click", function () {
          var rid = currentRespondentId();
          if (!rid && !confirm("Anda belum mengisi Respondent ID. Lanjutkan tanpa respondent_id?")) return;
          if (!pointIdEl || !pointIdEl.dataset.lat || !pointIdEl.dataset.lon) {
            alert("Silakan klik peta untuk memilih lokasi terlebih dahulu.");
            return;
          }

          var lat = parseFloat(pointIdEl.dataset.lat);
          var lon = parseFloat(pointIdEl.dataset.lon);
          var pid = "";
          if (pointIdEl.value && pointIdEl.value.trim()) pid = pointIdEl.value.trim();
          else pid = rid ? rid + "_P" + (pointsForRespondent(rid).length + 1) : "P" + (allPoints.length + 1);

          if (
            allPoints.some(function (x) {
              return x.point_id === pid && x.respondent_id === rid;
            })
          ) {
            pid = pid + "_" + (new Date().getTime() % 10000);
          }

          var acc = accuracyEl && accuracyEl.value ? accuracyEl.value.trim() : "";
          if (acc && isNaN(Number(acc))) {
            if (!confirm("Nilai accuracy bukan numerik. Simpan sebagai teks?")) return;
          }

          var rec = {
            respondent_id: rid || "",
            stakeholder_group: stakeholderEl ? stakeholderEl.value : "",
            mapping_object: mappingObjectEl ? (mappingObjectEl.value ? mappingObjectEl.value.trim() : "") : "",
            point_id: pid,
            latitude: lat,
            longitude: lon,
            timestamp: new Date().toISOString(),
            reason: reasonEl ? (reasonEl.value ? reasonEl.value.trim() : "") : "",
            map_source: mapSourceEl ? mapSourceEl.value : "",
            accuracy_m: acc,
          };

          var marker = L.circleMarker([lat, lon], { radius: 6, color: "#d9534f" }).addTo(map);
          var popupParts = ["<b>" + pid + "</b>"];
          if (rec.mapping_object) popupParts.push("<i>" + rec.mapping_object + "</i>");
          if (rec.reason) popupParts.push(rec.reason);
          marker.bindPopup(popupParts.join("<br/>"));

          rec.marker = marker;
          allPoints.push(rec);

          if (tempMarker) {
            map.removeLayer(tempMarker);
            tempMarker = null;
          }
          resetFormFields();
          updatePointsUI();
        });

      // Export helpers
      function escapeCsvCell(s) {
        if (s === null || s === undefined) return '""';
        var str = String(s).replace(/"/g, '""');
        return '"' + str + '"';
      }

      function convertToCsv(arr) {
        var header = ["respondent_id", "stakeholder_group", "mapping_object", "point_id", "latitude", "longitude", "timestamp", "reason", "map_source", "accuracy_m"];
        var lines = [header.join(",")];
        arr.forEach(function (r) {
          var row = [
            escapeCsvCell(r.respondent_id || ""),
            escapeCsvCell(r.stakeholder_group || ""),
            escapeCsvCell(r.mapping_object || ""),
            escapeCsvCell(r.point_id || ""),
            r.latitude != null ? r.latitude : "",
            r.longitude != null ? r.longitude : "",
            escapeCsvCell(r.timestamp || ""),
            escapeCsvCell(r.reason || ""),
            escapeCsvCell(r.map_source || ""),
            escapeCsvCell(r.accuracy_m || ""),
          ];
          lines.push(row.join(","));
        });
        return lines.join("\n");
      }

      function downloadText(filename, text, mimeType) {
        mimeType = mimeType || "text/csv;charset=utf-8;";
        var bom = "\uFEFF";
        var blob = new Blob([bom + text], { type: mimeType });
        var link = document.createElement("a");
        if (link.download !== undefined) {
          var url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          link.setAttribute("download", filename);
          link.style.visibility = "hidden";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } else alert("Browser Anda tidak mendukung pengunduhan otomatis.");
      }

      // Export CSV
      if (exportCsvBtn)
        exportCsvBtn.addEventListener("click", function () {
          var rid = currentRespondentId();
          var arr = [];
          if (rid) {
            var count = pointsForRespondent(rid).length;
            if (count < 10 && !confirm("Perhatian: untuk respondent " + rid + " hanya terkumpul " + count + " titik. Minimum yang direkomendasikan adalah 10 titik. Apakah Anda tetap ingin mengekspor data ini?")) return;
            arr = pointsForRespondent(rid);
          } else {
            if (!confirm("Tidak ada Respondent ID. Akan mengekspor semua titik (" + allPoints.length + "). Lanjutkan?")) return;
            arr = allPoints;
          }
          if (!arr || arr.length === 0) {
            alert("Tidak ada titik untuk diekspor.");
            return;
          }
          var csv = convertToCsv(arr);
          var fname = "preference_points_" + (rid ? rid : "all") + "_" + new Date().toISOString().slice(0, 19).replace(/[:T]/g, "_") + ".csv";
          downloadText(fname, csv, "text/csv;charset=utf-8;");
        });

      // Export GeoJSON
      if (exportGeoBtn)
        exportGeoBtn.addEventListener("click", function () {
          var rid = currentRespondentId();
          var arr = [];
          if (rid) {
            var count = pointsForRespondent(rid).length;
            if (count < 10 && !confirm("Perhatian: untuk respondent " + rid + " hanya terkumpul " + count + " titik. Minimum yang direkomendasikan adalah 10 titik. Apakah Anda tetap ingin mengekspor data ini?")) return;
            arr = pointsForRespondent(rid);
          } else {
            if (!confirm("Tidak ada Respondent ID. Akan mengekspor semua titik (" + allPoints.length + "). Lanjutkan?")) return;
            arr = allPoints;
          }
          if (!arr || arr.length === 0) {
            alert("Tidak ada titik untuk diekspor.");
            return;
          }
          var gj = { type: "FeatureCollection", features: [] };
          arr.forEach(function (p) {
            var f = {
              type: "Feature",
              properties: {
                respondent_id: p.respondent_id,
                stakeholder_group: p.stakeholder_group,
                mapping_object: p.mapping_object,
                point_id: p.point_id,
                timestamp: p.timestamp,
                reason: p.reason,
                map_source: p.map_source,
                accuracy_m: p.accuracy_m,
              },
              geometry: { type: "Point", coordinates: [p.longitude, p.latitude] },
            };
            gj.features.push(f);
          });
          var fname = "preference_points_geojson_" + (rid ? rid : "all") + "_" + new Date().toISOString().slice(0, 19).replace(/[:T]/g, "_") + ".geojson";
          downloadText(fname, JSON.stringify(gj), "application/geo+json;charset=utf-8;");
        });

      // Clear all
      if (clearAllBtn)
        clearAllBtn.addEventListener("click", function () {
          if (!confirm("Hapus semua titik?")) return;
          allPoints.forEach(function (p) {
            if (p.marker) map.removeLayer(p.marker);
          });
          allPoints = [];
          updatePointsUI();
        });

      // Center Btn
      if (centerBtn)
        centerBtn.addEventListener("click", function () {
          if (navigator.geolocation)
            navigator.geolocation.getCurrentPosition(
              function (pos) {
                map.setView([pos.coords.latitude, pos.coords.longitude], 15);
              },
              function () {
                alert("Tidak dapat memperoleh lokasi saat ini.");
              }
            );
          else alert("Geolocation tidak tersedia di browser ini.");
        });

      // Right-panel handlers
      if (getLocationBtn)
        getLocationBtn.addEventListener("click", function () {
          if (!navigator.geolocation) {
            alert("Geolocation tidak tersedia di browser ini.");
            return;
          }
          getLocationBtn.disabled = true;
          getLocationBtn.textContent = "Locating...";
          navigator.geolocation.getCurrentPosition(
            function (pos) {
              var lat = pos.coords.latitude,
                lon = pos.coords.longitude;
              map.setView([lat, lon], 16);
              var m = L.circleMarker([lat, lon], { radius: 8, color: "#337ab7" }).addTo(map);
              m.bindPopup("<b>Your location</b>").openPopup();
              setTimeout(function () {
                if (map && m) map.removeLayer(m);
              }, 10000);
              getLocationBtn.disabled = false;
              getLocationBtn.textContent = "Get my location";
            },
            function (err) {
              alert("Gagal mendapatkan lokasi: " + (err.message || "permission denied"));
              getLocationBtn.disabled = false;
              getLocationBtn.textContent = "Get my location";
            },
            { enableHighAccuracy: true, timeout: 10000 }
          );
        });
      if (zoomInBtn)
        zoomInBtn.addEventListener("click", function () {
          map.zoomIn();
        });
      if (zoomOutBtn)
        zoomOutBtn.addEventListener("click", function () {
          map.zoomOut();
        });

      // avoid auto-center on load
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          function () {},
          function () {},
          { enableHighAccuracy: false }
        );
      }

      // --- Administrative layers (external data/) ---
      var adminLayers = { WADMPR: null, WADMKK: null, WADMKC: null, WADMKD: null };
      // track level mapping so we can restore styles later
      var adminLayerLevels = { WADMPR: null, WADMKK: null, WADMKC: null, WADMKD: null };

      function styleFor(level) {
        switch (level) {
          case "prov":
            return { color: "#4b2e83", weight: 5, fill: false, opacity: 0.9 };
          case "kab":
            return { color: "#2b7fb8", weight: 3.5, fill: false, opacity: 0.9 };
          case "kec":
            return { color: "#2c7a3e", weight: 2.5, fill: false, opacity: 0.9 };
          case "desa":
            return { color: "#666", weight: 1.5, fill: false, opacity: 0.9 };
          default:
            return { color: "#000", weight: 1, fill: false };
        }
      }

      async function loadAdminGeojson(key, url, level) {
        // try a few candidate URLs
        var candidates = [url, url.toLowerCase(), url.replace(/\.geojson$/i, ".json"), url.replace(/^data\//, "")];
        // absolute based on current location
        try {
          var base = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, "");
          candidates.push(base + "/" + url);
        } catch (e) {}
        candidates = candidates.filter(function (v, i) {
          return candidates.indexOf(v) === i;
        });

        if (adminLayers[key]) {
          try {
            map.removeLayer(adminLayers[key]);
          } catch (e) {}
          adminLayers[key] = null;
          adminLayerLevels[key] = null;
        }

        var errors = [];
        for (var i = 0; i < candidates.length; i++) {
          var u = candidates[i];
          try {
            var resp = await fetch(u, { cache: "no-store" });
            if (!resp.ok) {
              errors.push({ url: u, status: resp.status });
              continue;
            }
            var gj = await resp.json();
            var layer = L.geoJSON(gj, {
              style: styleFor(level),
              onEachFeature: function (feature, lyr) {
                var props = feature && feature.properties ? feature.properties : {};
                var name = props.WADMKD || props.WADMKC || props.WADMKK || props.WADMPR || props.NAMOBJ || "";
                var cls = "admin-label admin-label-" + level;
                if (name) lyr.bindTooltip(String(name), { permanent: true, direction: "center", className: cls });
              },
            }).addTo(map);
            if (level === "prov")
              try {
                if (layer.bringToBack) layer.bringToBack();
              } catch (e) {}
            if (level === "desa")
              try {
                if (layer.bringToFront) layer.bringToFront();
              } catch (e) {}
            adminLayers[key] = layer;
            adminLayerLevels[key] = level;
            // remove any debug entry
            var dbg = document.getElementById("admin_debug_" + key);
            if (dbg) dbg.remove();
            console.log("Loaded", key, "from", u);
            return layer;
          } catch (err) {
            errors.push({ url: u, error: err && err.message ? err.message : String(err) });
            continue;
          }
        }
        // show debug panel
        var container = document.getElementById("sidebarRight");
        var panel = document.createElement("div");
        panel.id = "admin_debug_" + key;
        panel.style.background = "rgba(255,240,240,0.95)";
        panel.style.padding = "6px";
        panel.style.marginTop = "8px";
        panel.style.border = "1px solid #f2a0a0";
        panel.style.borderRadius = "6px";
        var html = "<b>Failed to load " + key + '</b><br/><div style="font-size:12px;margin-top:6px">Attempted URLs:</div><ul>';
        errors.forEach(function (e) {
          if (e.status) html += "<li>" + e.url + " — HTTP " + e.status + "</li>";
          else html += "<li>" + e.url + " — " + (e.error || "network error") + "</li>";
        });
        html += '</ul><div style="font-size:12px;margin-top:6px">Pastikan file tersedia di folder <code>/data/</code> dengan nama yang tepat (case-sensitive).</div>';
        panel.innerHTML = html;
        container.appendChild(panel);
        console.error("Failed loading", key, errors);
        throw new Error("Failed to load " + key);
      }

      function keyForLevel(level) {
        switch (level) {
          case "prov":
            return "WADMPR";
          case "kab":
            return "WADMKK";
          case "kec":
            return "WADMKC";
          case "desa":
            return "WADMKD";
          default:
            return "WADMPR";
        }
      }
      function urlForKey(key) {
        return { WADMPR: "data/WADMPR.geojson", WADMKK: "data/WADMKK.geojson", WADMKC: "data/WADMKC.geojson", WADMKD: "data/WADMKD.geojson" }[key];
      }
      function matchName(props) {
        return (props.WADMKD || props.WADMKC || props.WADMKK || props.WADMPR || props.NAMOBJ || "").toString();
      }

      // build Search by Administrative UI (hidden layer controls)
      (function () {
        var searchContainer = document.getElementById("admin_search_container");
        searchContainer.innerHTML =
          "<b>Search by Administrative</b><br/>" +
          '<label style="display:block;margin-top:6px; font-weight:600;">Level</label>' +
          '<select id="search_admin_level" style="width:100%; padding:6px; box-sizing:border-box">' +
          '<option value="prov">Provinsi</option>' +
          '<option value="kab">Kabupaten/Kota</option>' +
          '<option value="kec">Kecamatan</option>' +
          '<option value="desa">Desa</option>' +
          "</select>" +
          '<label style="display:block;margin-top:8px; font-weight:600;">Nama wilayah</label>' +
          '<div style="position:relative">' +
          '<input id="search_admin_query" type="text" autocomplete="off" placeholder="Masukkan nama (mis. Jawa Tengah)" style="width:100%; padding:6px; box-sizing:border-box" />' +
          '<div id="admin_suggestions" style="position:absolute; left:0; right:0; top:40px; background:#fff; border:1px solid #ddd; max-height:180px; overflow:auto; display:none; z-index:2000;"></div>' +
          "</div>" +
          '<div style="display:flex; gap:8px; margin-top:8px;">' +
          '<button id="btn_admin_search" class="btn">Search</button>' +
          '<button id="btn_admin_clear" class="btn secondary">Clear</button>' +
          "</div>" +
          '<div id="admin_search_results" style="margin-top:8px; max-height:200px; overflow:auto; font-size:13px"></div>';

        var suggestionBox = document.getElementById("admin_suggestions");
        var queryInput = document.getElementById("search_admin_query");

        function debounce(fn, wait) {
          var t;
          return function () {
            var args = arguments;
            clearTimeout(t);
            t = setTimeout(function () {
              fn.apply(null, args);
            }, wait);
          };
        }

        function getNamesFromLayer(key) {
          return new Promise(function (resolve, reject) {
            var layer = adminLayers[key];
            if (!layer) return reject(new Error("Layer not loaded"));
            var set = {};
            var list = [];
            layer.eachLayer(function (l) {
              var feat = l.feature;
              var props = feat && feat.properties ? feat.properties : {};
              var name = matchName(props);
              if (!name) return;
              var n = String(name).trim();
              if (n && !set[n.toLowerCase()]) {
                set[n.toLowerCase()] = true;
                list.push(n);
              }
            });
            resolve(
              list.sort(function (a, b) {
                return a.localeCompare(b);
              })
            );
          });
        }

        function fetchNamesFromGeojson(url) {
          return fetch(url, { cache: "no-store" })
            .then(function (r) {
              if (!r.ok) throw new Error("HTTP " + r.status);
              return r.json();
            })
            .then(function (gj) {
              var set = {};
              var list = [];
              if (!gj || !gj.features) return [];
              gj.features.forEach(function (f) {
                var props = f.properties || {};
                var name = matchName(props);
                if (!name) return;
                var n = String(name).trim();
                if (n && !set[n.toLowerCase()]) {
                  set[n.toLowerCase()] = true;
                  list.push(n);
                }
              });
              return list.sort(function (a, b) {
                return a.localeCompare(b);
              });
            })
            .catch(function () {
              return [];
            });
        }

        function showSuggestions(arr) {
          if (!arr || arr.length === 0) {
            suggestionBox.style.display = "none";
            suggestionBox.innerHTML = "";
            return;
          }
          suggestionBox.innerHTML = "";
          var max = Math.min(arr.length, 10);
          for (var i = 0; i < max; i++) {
            var item = document.createElement("div");
            item.style.padding = "6px 8px";
            item.style.borderBottom = "1px solid #f1f1f1";
            item.style.cursor = "pointer";
            item.textContent = arr[i];
            (function (text) {
              item.addEventListener("click", function () {
                queryInput.value = text;
                suggestionBox.style.display = "none";
                suggestionBox.innerHTML = "";
                document.getElementById("btn_admin_search").click();
              });
            })(arr[i]);
            suggestionBox.appendChild(item);
          }
          suggestionBox.style.display = "block";
        }

        function updateSuggestionsForQuery(q) {
          var level = document.getElementById("search_admin_level").value;
          var key = keyForLevel(level);
          console.log("[admin-autocomplete] updateSuggestionsForQuery:", key, q);
          suggestionBox.innerHTML = "";
          suggestionBox.style.display = "block";
          // show loading hint
          var loading = document.createElement("div");
          loading.style.padding = "6px";
          loading.style.color = "#666";
          loading.textContent = "Loading suggestions...";
          suggestionBox.appendChild(loading);

          var promiseNames;
          if (adminLayers[key]) {
            promiseNames = getNamesFromLayer(key);
          } else {
            // prefer to load layer (gives better chance to access names, and will surface debug if fails)
            promiseNames = loadAdminGeojson(key, urlForKey(key), level)
              .then(function () {
                return getNamesFromLayer(key);
              })
              .catch(function (err) {
                console.warn("[admin-autocomplete] loadAdminGeojson failed:", err);
                // as fallback try fetching raw geojson
                return fetchNamesFromGeojson(urlForKey(key));
              });
          }

          promiseNames
            .then(function (list) {
              // remove loading
              suggestionBox.innerHTML = "";
              if (!list || list.length === 0) {
                suggestionBox.style.display = "none";
                return;
              }
              if (!q) {
                showSuggestions(list.slice(0, 10));
                return;
              }
              var mq = q.toLowerCase();
              var filtered = list.filter(function (s) {
                return s.toLowerCase().indexOf(mq) !== -1;
              });
              showSuggestions(filtered);
            })
            .catch(function (err) {
              console.warn("[admin-autocomplete] promiseNames failed", err);
              suggestionBox.innerHTML = "";
              suggestionBox.style.display = "none";
            });
        }

        var debouncedUpdate = debounce(function () {
          updateSuggestionsForQuery(queryInput.value.trim());
        }, 250);
        (function () {
          updateSuggestionsForQuery(queryInput.value.trim());
        }),
          250;
        queryInput.addEventListener("input", debouncedUpdate);
        queryInput.addEventListener("focus", function () {
          debouncedUpdate();
        });
        queryInput.addEventListener("blur", function () {
          setTimeout(function () {
            suggestionBox.style.display = "none";
          }, 200);
        });

        var highlightLayer = null;
        function clearHighlight() {
          if (highlightLayer) {
            try {
              map.removeLayer(highlightLayer);
            } catch (e) {}
            highlightLayer = null;
          }
        }

        function searchInLayer(key, q) {
          return new Promise(function (resolve, reject) {
            var layer = adminLayers[key];
            if (!layer) return reject(new Error("Layer not loaded"));
            var matches = [];
            layer.eachLayer(function (l) {
              var feat = l.feature;
              var props = feat && feat.properties ? feat.properties : {};
              var name = matchName(props);
              if (!name) return;
              if (name.toLowerCase().indexOf(q.toLowerCase()) !== -1) {
                matches.push({ name: name, layer: l, feature: feat });
              }
            });
            resolve(matches);
          });
        }

        function hideAllAdminLayers() {
          Object.keys(adminLayers).forEach(function (k) {
            var layer = adminLayers[k];
            try {
              if (!layer) return;
              // FIX: Remove layer completely so tooltips disappear too
              if (map.hasLayer(layer)) {
                map.removeLayer(layer);
              }
            } catch (e) {
              console.warn("hideAllAdminLayers err", e);
            }
          });
        }
        function restoreAdminLayers() {
          Object.keys(adminLayers).forEach(function (k) {
            var layer = adminLayers[k];
            var lvl = adminLayerLevels[k] || null;
            try {
              if (!layer) return;
              if (typeof layer.setStyle === "function" && lvl) {
                var s = styleFor(lvl);
                // setStyle expects color/weight/opacity/fillOpacity
                layer.setStyle({ color: s.color || "#000", weight: s.weight || 1, opacity: s.opacity || 1, fillOpacity: s.fill ? s.fillOpacity || 0.2 : 0 });
                // ensure layer is added to map
                if (map.hasLayer && !map.hasLayer(layer)) map.addLayer(layer);
              } else {
                if (map.hasLayer && !map.hasLayer(layer)) map.addLayer(layer);
              }
            } catch (e) {
              console.warn("restoreAdminLayers err", e);
            }
          });
        }

        function resetAdminView() {
          // 1. Reset input text
          document.getElementById("search_admin_query").value = "";

          // 2. Clear results list
          document.getElementById("admin_search_results").innerHTML = "";

          // 3. Hide suggestions if visible
          var suggestionBox = document.getElementById("admin_suggestions");
          if (suggestionBox) {
            suggestionBox.style.display = "none";
            suggestionBox.innerHTML = "";
          }

          // 4. Remove highlight (orange lines)
          clearHighlight();

          // 5. REMOVE ALL ADMIN LAYERS completely (Fix: use hideAllAdminLayers instead of restore)
          hideAllAdminLayers();
        }

        function showResultsList(matches) {
          var container = document.getElementById("admin_search_results");
          container.innerHTML = "";
          if (!matches || matches.length === 0) {
            container.innerHTML = '<div class="small">Tidak ditemukan.</div>';
            return;
          }

          // When search results are shown, hide all full admin layers and display only the matched feature(s).
          hideAllAdminLayers();
          // remove previous highlightLayer if any
          clearHighlight();

          // Create a FeatureCollection with all matched features
          var fc = {
            type: "FeatureCollection",
            features: matches.map(function (m) {
              return m.feature;
            }),
          };
          highlightLayer = L.geoJSON(fc, {
            style: function () {
              return { color: "#ff7800", weight: 4, fill: false };
            },
          }).addTo(map);

          // zoom to bounds of matched features
          try {
            var bounds = highlightLayer.getBounds();
            if (bounds && bounds.isValid()) map.fitBounds(bounds, { maxZoom: 13 });
          } catch (e) {
            console.warn(e);
          }

          // list results with option to focus a single feature (still only matched features are visible)
          matches.forEach(function (m, idx) {
            var row = document.createElement("div");
            row.style.padding = "6px";
            row.style.borderBottom = "1px solid #eee";
            row.style.display = "flex";
            row.style.justifyContent = "space-between";
            row.style.alignItems = "center";
            row.innerHTML = '<div style="flex:1"><b>' + (idx + 1) + "</b> " + m.name + "</div>";
            var btn = document.createElement("button");
            btn.className = "btn tertiary";
            btn.textContent = "Zoom";
            btn.addEventListener("click", function () {
              try {
                // zoom to this matched feature only
                var singleFc = { type: "FeatureCollection", features: [m.feature] };
                // replace highlightLayer with single feature
                if (highlightLayer) {
                  try {
                    map.removeLayer(highlightLayer);
                  } catch (e) {}
                  highlightLayer = null;
                }
                highlightLayer = L.geoJSON(singleFc, {
                  style: function () {
                    return { color: "#ff7800", weight: 4, fill: false };
                  },
                }).addTo(map);
                var b = L.geoJSON(m.feature).getBounds();
                if (b && b.isValid()) map.fitBounds(b, { maxZoom: 13 });
              } catch (e) {
                console.warn(e);
              }
            });
            row.appendChild(btn);
            container.appendChild(row);
          });

          // add a restore button to allow returning to full layer view
          var restoreBtn = document.createElement("button");
          restoreBtn.className = "btn secondary";
          restoreBtn.style.marginTop = "8px";
          restoreBtn.textContent = "Restore all administrative layers";
          restoreBtn.addEventListener("click", function () {
            // Restore layers, but keep user context
            clearHighlight();
            restoreAdminLayers();
          });
          container.appendChild(restoreBtn);
        }

        // Search handler
        document.getElementById("btn_admin_search").addEventListener("click", function () {
          var level = document.getElementById("search_admin_level").value;
          var q = document.getElementById("search_admin_query").value.trim();
          if (!q) {
            alert("Masukkan nama wilayah yang ingin dicari.");
            return;
          }
          var key = keyForLevel(level);
          if (!adminLayers[key]) {
            loadAdminGeojson(key, urlForKey(key), level)
              .then(function () {
                return searchInLayer(key, q);
              })
              .then(function (matches) {
                showResultsList(matches);
              })
              .catch(function (err) {
                alert("Gagal memuat layer administratif untuk pencarian: " + (err && err.message ? err.message : err));
              });
          } else {
            searchInLayer(key, q).then(function (matches) {
              showResultsList(matches);
            });
          }
        });

        document.getElementById("btn_admin_clear").addEventListener("click", resetAdminView);
      })();
    </script>
  </body>
</html>
